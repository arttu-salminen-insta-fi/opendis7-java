/**
 * Copyright (c) 2008-2021, MOVES Institute, Naval Postgraduate School (NPS). All rights reserved.
 * This work is provided under a BSD open-source license, see project license.html and license.txt
 */
package edu.nps.moves.dis7.utilities.stream;

import com.google.common.primitives.Longs;
import edu.nps.moves.dis7.enumerations.DisPduType;
import java.io.*;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.regex.Pattern;

/** Utility to play back log files of recorded PDUs, found in ancestor <code>pduLogs</code> subdirectory. These PDUs can then be resent
 * over a multicast group address, or processed locally.
 * 
 * Example <code>main()</code> self-test response shown in log file.
 * @see <a href="https://github.com/open-dis/open-dis7-java/blob/master/src/edu/nps/moves/dis7/utilities/stream/PduPlayerSelfTestLog.txt">https://github.com/open-dis/open-dis7-java/blob/master/src/edu/nps/moves/dis7/utilities/stream/PduPlayerSelfTestLog.txt</a>
 * 
 * @author Don Brutzman, brutzman@nps.edu
 * @author Mike Bailey, jmbailey@nps.edu
 */
public class PduPlayer {

    /** PDU listener interface */
    public interface RawListener {
        /** callback
         * @param ba byte array for receipts */
        void receiveBytes(byte[] ba);
    }
    
    private Path disLogDirectory;
    private String ip;
    private int port;
    private Thread playerThread;

    static final String ENCODING_BASE64          = "ENCODING_BASE64";
    static final String ENCODING_PLAINTEXT       = "ENCODING_PLAINTEXT";
    static final String ENCODING_BINARY          = "ENCODING_BINARY";  // TODO likely requires different code path
    static final String ENCODING_XML             = "ENCODING_XML";     // TODO, repeat Open-DIS version 4 effort
    static final String ENCODING_EXI             = "ENCODING_EXI";     // TODO, use Exificient or Nagasena libraries
    static final String ENCODING_JSON            = "ENCODING_JSON";    // TODO, repeat Open-DIS version 4 effort
    static final String ENCODING_CDIS            = "ENCODING_CDIS";    // future work based on new SISO standard
    static final String ENCODING_MAK_DATA_LOGGER = "ENCODING_MAK_DATA_LOGGER";        // verbose pretty-print. perhaps output only (MAK format itself is binary)
    static final String ENCODING_WIRESHARK_DATA_LOGGER = "ENCODING_WIRESHARK_DATA_LOGGER"; // 

    private static String pduLogEncoding = PduRecorder.ENCODING_PLAINTEXT; // determined when reading file

    /** Constructor that spawns the player thread.
     * 
     * @param ip the multicast group address to utilize
     * @param port the multicast port to utilize
     * @param disLogDirectory a path to the directory containing PDU log files
     * @param sendToNet to capture X3D interpolator values - if desired
     * @throws IOException if something goes wrong processing files
     */
    public PduPlayer(String ip, int port, Path disLogDirectory, boolean sendToNet) throws IOException 
    {
        this.disLogDirectory = disLogDirectory;
        this.ip = ip;
        this.port = port;
        this.netSend = sendToNet;

        playerThread = new Thread(() -> { } ); // begin() - avoid starting thread begin() without programmer direction?
        playerThread.setPriority(Thread.NORM_PRIORITY);
        playerThread.setName("PlayerThread");
        playerThread.setDaemon(true);
        playerThread.start();
    }

    private Integer scenarioPduCount = null;
    private boolean showPduCountsOneTime = false;
    private int pduCount = 0;
    private DatagramSocket datagramSocket;
    private Long startNanoTime = null;
    private boolean paused = false;
    private boolean netSend = true;
    private RawListener rawListener = null;

    //ToDo: Add X3d for BASE64 Encoding
    // -------------------- Begin Variables for X3D autogenerated code
    private X3dCreateInterpolators x3dInterpolators = new X3dCreateInterpolators();
    private X3dCreateLineSet x3dLineSet = new X3dCreateLineSet();
    private byte[] globalByteBufferForX3dInterpolators = null;
    // -------------------- End Variables for X3D autogenerated code
    
    /**
     * Method to add listener
     * @param listener listener of interest
     */
    public void addRawListener(RawListener listener) {
        rawListener = listener;
    }

    /** Thread process for this class */
    @SuppressWarnings("StatementWithEmptyBody")
    public void begin() 
    {
        try {
            System.out.println("PduPlayer begin() playing DIS logs found in ancestor pduLog directory.");
            
            InetAddress addr = null;
            DatagramPacket datagramPacket;
            DisPduType pduType;
            String tempString;
            String[] sa = null, splitString;
            String REGEX;
            Pattern pattern;
            byte[] pduTimeBytes = new byte[8]; // timestamp is always 8 bytes
            byte[] byteBufferShort = null;
            int[] intArray;
            IntBuffer intBuffer;
            int tempInt;
            ByteBuffer byteBuffer1, byteBuffer2;
            long pduTimeInterval, targetSimTime, now, sleepTime;

            FilenameFilter filenameFilter = (dir, name) -> {
                return name.endsWith(PduRecorder.DISLOG_FILE_EXTENSION) && !name.startsWith(".");
            };

            File[] filesArray = disLogDirectory.toFile().listFiles(filenameFilter);
            if (filesArray == null) {
                filesArray = new File[0];
            }

            Arrays.sort(filesArray, (f1, f2) -> {
                return f1.getName().compareTo(f2.getName());
            });

            if (netSend) 
            {
                addr = InetAddress.getByName(ip);
                datagramSocket = new DatagramSocket();
            }
            
            Base64.Decoder base64Decoder = Base64.getDecoder();

            for (File f : filesArray) 
            {
                List<String> lines = Files.readAllLines(Path.of(f.getAbsolutePath()));

                if      (f.getName().contains("BASE64") || lines.get(0).startsWith("AAAAA")) // TODO include header??
                     pduLogEncoding = PduRecorder.ENCODING_BASE64;
                else if (f.getName().contains("PLAINTEXT") || lines.get(0).contains("PLAINTEXT"))
                     pduLogEncoding = PduRecorder.ENCODING_PLAINTEXT;
                else pduLogEncoding = PduRecorder.ENCODING_BINARY;
                
                System.out.flush();
                System.err.flush();
                System.out.println("Replaying PDU log file with " + pduLogEncoding + ": " + f.getAbsolutePath());
                    
                for (String line : lines)
                {
                    while (paused) {
                        sleep(100l); // TODO confirm usability OK, currently 100 msec increments for pause
                    }
                    if (line.length() <= 0)
                        ; // blank lines ok
                    else if (line.trim().startsWith(PduRecorder.COMMENT_MARKER)) {
                        if (handleComment(line, f)) {
                            break;
                        }
                    } 
                    else
                    {
                        switch (pduLogEncoding) 
                        {
                            case PduRecorder.ENCODING_BASE64:
                                sa = new String[1]; // one big string per line per PDU
                                sa[0] = line;
                                break;

                            case PduRecorder.ENCODING_PLAINTEXT:

                                if (line.contains(PduRecorder.COMMENT_MARKER)) {
                                    line = line.substring(0, line.indexOf(PduRecorder.COMMENT_MARKER) - 1); //Delete appended Comments
                                }
                                if (line.contains("[") || line.contains("]"))
                                {
                                    System.out.println("*** [square brackets] no longer included in CSV PLAINTEXT data, ignored");
                                    line = line.replace("[","").replace("]","");
                                }
                                //Pattern splitting needed for playback of unencoded streams
//                                REGEX = "\\],\\[";
                                REGEX = ",";
                                pattern = Pattern.compile(REGEX);

                                sa = pattern.split(line);
//                                //Add the "]" to the end of sa[0]. It was taken off by the split
//                                sa[0] = sa[0].concat("]");
//                                //Add the "]" to the end of sa[0]. It was taken off by the split
//                                if (sa.length > 1)
//                                    sa[1] = "[".concat(sa[1]);

                                break;

                            default:
                                System.err.println("Encoding'" + pduLogEncoding + " not recognized or supported");
                        }

                        // timestamp is 8 bytes, size of smallest PDU?
                        if (pduLogEncoding.equals(PduRecorder.ENCODING_PLAINTEXT) && 
                            (sa != null) && (sa.length < 8) && (sa.length != 0))
                        {
                            System.err.println("Error: ENCODING_PLAINTEXT parsing error due to line too short, offending line follows:");
                            System.err.println(line);
                            exitWithFailure();
                        }

                        if (startNanoTime == null) {
                            startNanoTime = System.nanoTime(); // initialize
                        }
                        // get timestamp pduTimeBytes, i.e. 8 bytes represented by a Java long
                        switch (pduLogEncoding)
                        {
                            case PduRecorder.ENCODING_BINARY:
                                // TODO
                                break;
                                
                            case PduRecorder.ENCODING_BASE64:
                                // no longer computed separately in BASE64, one single block is decompressed instead of two
//                              pduTimeBytes = base64Decoder.decode(sa[0]); 
                                break;

                            case PduRecorder.ENCODING_PLAINTEXT:

//                                // Split first String into multiple Strings cotaining integers
//                                REGEX = ",";
//                                pattern = Pattern.compile(REGEX);
//
////                                sa[0] = sa[0].substring(1, sa[0].length() - 1); // no longer has prepended [
//
//                                splitString = pattern.split(sa[0]);
//
//                                //Define an array to store the in values from the string and initalize it to a value different from NULL
//                                intArray = new int[8];
//
//                                //Test
//                                for (int x = 0; x < splitString.length; x++) {
//
//                                    tempString = splitString[x].trim();
//
//                                    tempInt = Integer.parseInt(tempString);
//                                    arr[x] = tempInt;
//                                }
//                                // Credit:  https://stackoverflow.com/questions/1086054/how-to-convert-int-to-byte
//                                byteBuffer1 = ByteBuffer.allocate(arr.length * 4);
//                                intBuffer = byteBuffer1.asIntBuffer();
//                                intBuffer.put(arr);
//
//                                pduTimeBytes = byteBuffer1.array();
                                
                                for (int i = 0; i < 8; i++)
                                {
                                    pduTimeBytes[i] = Byte.parseByte(sa[i]);
                                }
                                break;

                            default:
                                System.err.println("Encoding'" + pduLogEncoding + " not recognized or supported");
                        }

                        pduTimeInterval = Longs.fromByteArray(pduTimeBytes);
                        // This is a relative number in nanoseconds of the time of packet reception minus first packet reception for scenario.

                        targetSimTime = startNanoTime + pduTimeInterval;  // when we should send the packet
                        now = System.nanoTime();
                        sleepTime = targetSimTime - now; // the difference between then and now

                        if (sleepTime > 20000000) { // 20 msec
                            //System.out.println("sim interval = " + pduTimeInterval + ", sleeping for " + sleepTime/1000000l + " ms");
                            sleep(sleepTime / 1000000L, (int) (sleepTime % 1000000L));
                        }

                        // now get rest of buffer for PDU fields
                        byte[] byteBuffer, pduBuffer;
                        switch (pduLogEncoding)
                        {
                            case PduRecorder.ENCODING_BASE64:
                                // TODO if string included prior comma, handle it
                                byteBuffer = base64Decoder.decode(sa[0]); // no longer a pair of comma-separated blocks
                                 pduBuffer = new byte[byteBuffer.length - 8];
                                // get pduTimeBytes from first 8 characters, then remainder of buffer
                                for (int i = 0; i < byteBuffer.length; i++)
                                {
                                    if (i < 8)
                                        pduTimeBytes[i] = byteBuffer[i];
                                    else pduBuffer[i-8] = byteBuffer[i];
                                }
                                
                                if (netSend) 
                                {
                                    datagramPacket = new DatagramPacket(pduBuffer, pduBuffer.length, addr, port);
                                    datagramSocket.send(datagramPacket);
                                    pduType = DisPduType.getEnumForValue(Byte.toUnsignedInt(pduBuffer[2])); // 3rd byte
                                    System.out.println("Sent PDU: " + pduType);
                                }
                                break;

                            case PduRecorder.ENCODING_PLAINTEXT:

                                //---Code Tobi for Plain Text---
                                // Handle the second String
                                // Split second String into multiple Strings containing integers
//                                REGEX = ",";
//                                pattern = Pattern.compile(REGEX);
//
////                                sa[1] = sa[1].substring(1, sa[1].length() - 1); // no longer has prepended [
//
//                                splitString = pattern.split(sa[1]);
//
//                                // Define an array to store the in values from the string and initalize it to a value different from NULL
//                                intArray = new int[splitString.length];
//
//                                //Test
//                                for (int x = 0; x < splitString.length; x++) {
//
//                                    tempString = splitString[x].trim();
//
//                                    tempInt = Integer.parseInt(tempString);
//                                    intArray[x] = tempInt;
//
//                                    //System.out.println(tempInt);
//                                }
//                                // Credit:  https://stackoverflow.com/questions/1086054/how-to-convert-int-to-byte
//                                byteBuffer2 = ByteBuffer.allocate(intArray.length * 4);
//                                intBuffer = byteBuffer2.asIntBuffer();
//                                intBuffer.put(intArray);
//
//                                buffer = byteBuffer2.array();
//
//                                //When the byteBuffer stores the array of Integers into the byte array it stores a 7 as 0 0 0 7.
//                                //Therefore a shortBuffer is created where only every fourth value is stored.
//                                //it must be done with modulo instead of testing for "0" because a "0" could be there as value and not as padding
//                                bufferShort = new byte[byteBuffer2.array().length / 4];
//
//                                int bufferShortCounter = 0;
//
//                                for (int i = 1; i < byteBuffer2.array().length; i++) {
//
//                                    if (((i + 1) % 4) == 0) {
//
//                                        bufferShort[bufferShortCounter] = buffer[i];
//                                        bufferShortCounter++;
//                                    }
//                                }
                                
                                byteBufferShort = new byte[sa.length - 8]; // skip first 8 bytes used for timestamp
                                for (int i = 8; i < byteBufferShort.length; i++)
                                {
                                    byteBufferShort[i-8] = Byte.parseByte(sa[i]);
                                }
                                if (netSend) {
                                    datagramPacket = new DatagramPacket(byteBufferShort, byteBufferShort.length, addr, port);
                                    datagramSocket.send(datagramPacket);
                                    pduType = DisPduType.getEnumForValue(Byte.toUnsignedInt(byteBufferShort[2])); // 3rd byte
                                    System.out.println("Sent PDU: " + pduType);
                                    
                                    // Add Points to X3D Components
//                                    globalByteBufferForX3dInterpolators = bufferShort.clone();
//                                    x3dInterpolators.addPointsToMap(globalByteBufferForX3dInterpolators); // gets cloned again
//                                    x3dLineSet.addPointsToMap(globalByteBufferForX3dInterpolators); // gets cloned again
                                }
                                break;

                            default:
                                break;
                        }

                        // TODO Is this also necessary for buffershort? If yes, put it inside the switch/Case statement
                        if (rawListener != null) {
                            rawListener.receiveBytes(byteBufferShort);
                        }
                        pduCount++;
                        if (scenarioPduCount != null) {
                            scenarioPduCount++; // also increment overall PDU count
                        }

                        if (showPduCountsOneTime || pduCount % 5 == 0) {
//                            showCounts(); // TODO
                        }
                    }
                }
                
                //create X3D components - methods will create console output
                if (netSend) {
//                    x3dInterpolators.makeX3dInterpolator();
//                    x3dLineSet.makeX3dLineSet();
                }
            }
            if (rawListener != null) {
                rawListener.receiveBytes(null); // indicate the end
            }
        } catch (IOException ex) {
            System.err.println("Exception reading/writing pdus: " + ex.getClass().getSimpleName() + ": " + ex.getLocalizedMessage());
            ex.printStackTrace();
            playerThread = null;
            closer();
        }
    }

    private void showCounts() {
        // use carriage return \r for transient display output as a run-time developer diagnostic
        // (possibly as part of earlier diagnosis of threading-related problems with dropped packets)
        if (scenarioPduCount != null) {
            System.out.print(pduCount + " " + ++scenarioPduCount + "..." + "\r"); // TODO where are the ... ? not appearing in output
        } else {
            System.out.print(pduCount + "\r");
        }
        showPduCountsOneTime = false;
    }

    private void exitWithFailure() throws IOException {
        System.out.println("Replay stopped.");
        closer();
        throw new IOException("PduPlayer parsing error");
    }

    private void closer() {
        netSend = false;
        if (datagramSocket != null) {
            datagramSocket.close();
            datagramSocket = null;
        }
    }

    private boolean handleComment(String line, File f) //true if we're done
    {
        boolean returnValue = false;
        if (line.trim().startsWith(PduRecorder.START_COMMENT_MARKER)) {
            
            //Read Encoding from FileHeader
            String[] sa = line.split(",", 3);
            pduLogEncoding = sa[1].trim();
            System.err.println(pduLogEncoding);
//            line = line.substring(PduRecorder.START_COMMENT_MARKER.length());
//            System.out.println(line + "  ");
            showPduCountsOneTime = true; // get the first one in there
        }
        else if (line.trim().startsWith(PduRecorder.FINISH_COMMENT_MARKER))
        {
            System.out.print("Total PDUs: ");
            showCounts();
            System.out.println();
            System.out.flush();
            System.err.flush();
            System.out.println("PduPlayer handleComment() found FINISH_COMMENT_MARKER, end of replay from log file " + f.getName());
//            System.out.println(line.substring(PduRecorder.FINISH_COMMENT_MARKER.length()));
            // reset counters
            scenarioPduCount = 0;
            startNanoTime = null;
            returnValue = true;
        }
        return returnValue;
    }
    /** Start or resume this instance */
    public void startResume() {
        paused = false;
    }

    /** Stop or pause this instance */
    public void stopPause() {
        paused = true;
    }

    /** End operation of this instance */
    public void end() {
        closer();
    }

    private void sleep(long ms) {
        sleep(ms, 0);
    }
    
    private void sleep(long ms, int ns) {
        // @formatter:off
        try {
            Thread.sleep(ms, ns);
        } catch (InterruptedException ex) {}
        // @formatter:on
    }
    
    /** Test execution for debugging
     * @param args command-line arguments (unused)
     */
    public static void main(String[] args)
    {
        String DEFAULT_OUTPUT_DIRECTORY  = "pduLog";
        /** Default multicast group address we send on.
          * @see <a href="https://en.wikipedia.org/wiki/Multicast_address">https://en.wikipedia.org/wiki/Multicast_address</a> */
        String  DEFAULT_MULTICAST_ADDRESS = "239.1.2.3";
        /** @see <a href="https://en.wikipedia.org/wiki/Port_(computer_networking)">https://en.wikipedia.org/wiki/Port_(computer_networking)</a> */
        int     DEFAULT_MULTICAST_PORT    = 3000;
        String  outputDirectory = DEFAULT_OUTPUT_DIRECTORY;
        String multicastAddress = DEFAULT_MULTICAST_ADDRESS;
        int       multicastPort = DEFAULT_MULTICAST_PORT;
        boolean sendToNet = true;
        
        try
        {
            // create instance of class in this static block
            PduPlayer pduPlayer = new PduPlayer(multicastAddress, multicastPort, Path.of(outputDirectory), sendToNet);
            // thread automatically starts up when class is instantiated
            pduPlayer.begin(); // default is self test through all logs in ancestor pduLog subdirectory
        }
        catch (IOException ioe)
        {
            System.out.println("PduPlayer exception in main(): " + ioe.getMessage());
        }
    }
}
