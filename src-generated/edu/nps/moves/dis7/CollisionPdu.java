/**
 * Copyright (c) 2008-2020, MOVES Institute, Naval Postgraduate School (NPS). All rights reserved.
 * This work is provided under a BSD open-source license, see project license.html and license.txt
 */

package edu.nps.moves.dis7;

import java.util.*;
import java.io.*;
import edu.nps.moves.dis7.enumerations.*;

/**
 * 7.2.3 Collisions between entities shall be communicated by issuing a Collision PDU. See 5.3.3.
 * IEEE Std 1278.1-2012, IEEE Standard for Distributed Interactive Simulation - Application Protocols
 */
public class CollisionPdu extends EntityInformationFamilyPdu implements Serializable
{
   /** This field shall identify the entity that is issuing the PDU, and shall be represented by an Entity Identifier record (see 6.2.28). */
   protected EntityID  issuingEntityID = new EntityID(); 

   /** This field shall identify the entity that has collided with the issuing entity (see 5.3.3.4). This field shall be represented by an Entity Identifier record (see 6.2.28). */
   protected EntityID  collidingEntityID = new EntityID(); 

   /** This field shall contain an identification generated by the issuing simulation application to associate related collision events. This field shall be represented by an Event Identifier record (see 6.2.34). */
   protected EventIdentifier  eventID = new EventIdentifier(); 

   /** This field shall identify the type of collision. The Collision Type field shall be represented by an 8-bit record of enumerations uid 189 */
   protected CollisionType collisionType = CollisionType.values()[0];

   /** some padding */
   protected byte  pad = (byte)0;

   /** This field shall contain the velocity (at the time the collision is detected) of the issuing entity. The velocity shall be represented in world coordinates. This field shall be represented by the Linear Velocity Vector record [see 6.2.95 item c)]. */
   protected Vector3Float  velocity = new Vector3Float(); 

   /** This field shall contain the mass of the issuing entity, and shall be represented by a 32-bit floating point number representing kilograms. */
   protected float  mass;

   /** This field shall specify the location of the collision with respect to the entity with which the issuing entity collided. The Location field shall be represented by an Entity Coordinate Vector record [see 6.2.95 item a)]. */
   protected Vector3Float  location = new Vector3Float(); 


/** Constructor */
 public CollisionPdu()
 {
    setPduType( DISPDUType.COLLISION );
 }

/** Returns the size of this serialized object in bytes*/
public int getMarshalledSize()
{
   int marshalSize = 0; 

   marshalSize = super.getMarshalledSize();
   marshalSize += issuingEntityID.getMarshalledSize();
   marshalSize += collidingEntityID.getMarshalledSize();
   marshalSize += eventID.getMarshalledSize();
   marshalSize += collisionType.getMarshalledSize();
   marshalSize += 1;  // pad
   marshalSize += velocity.getMarshalledSize();
   marshalSize += 4;  // mass
   marshalSize += location.getMarshalledSize();

   return marshalSize;
}


/** Setter for {@link CollisionPdu#issuingEntityID}*/
public CollisionPdu setIssuingEntityID(EntityID pIssuingEntityID)
{
    issuingEntityID = pIssuingEntityID;
    return this;
}

/** Getter for {@link CollisionPdu#issuingEntityID}*/
public EntityID getIssuingEntityID()
{
    return issuingEntityID; 
}

/** Setter for {@link CollisionPdu#collidingEntityID}*/
public CollisionPdu setCollidingEntityID(EntityID pCollidingEntityID)
{
    collidingEntityID = pCollidingEntityID;
    return this;
}

/** Getter for {@link CollisionPdu#collidingEntityID}*/
public EntityID getCollidingEntityID()
{
    return collidingEntityID; 
}

/** Setter for {@link CollisionPdu#eventID}*/
public CollisionPdu setEventID(EventIdentifier pEventID)
{
    eventID = pEventID;
    return this;
}

/** Getter for {@link CollisionPdu#eventID}*/
public EventIdentifier getEventID()
{
    return eventID; 
}

/** Setter for {@link CollisionPdu#collisionType}*/
public CollisionPdu setCollisionType(CollisionType pCollisionType)
{
    collisionType = pCollisionType;
    return this;
}

/** Getter for {@link CollisionPdu#collisionType}*/
public CollisionType getCollisionType()
{
    return collisionType; 
}

/** Setter for {@link CollisionPdu#pad}*/
public CollisionPdu setPad(byte pPad)
{
    pad = pPad;
    return this;
}

/** Getter for {@link CollisionPdu#pad}*/
public byte getPad()
{
    return pad; 
}

/** Setter for {@link CollisionPdu#velocity}*/
public CollisionPdu setVelocity(Vector3Float pVelocity)
{
    velocity = pVelocity;
    return this;
}

/** Getter for {@link CollisionPdu#velocity}*/
public Vector3Float getVelocity()
{
    return velocity; 
}

/** Setter for {@link CollisionPdu#mass}*/
public CollisionPdu setMass(float pMass)
{
    mass = pMass;
    return this;
}

/** Getter for {@link CollisionPdu#mass}*/
public float getMass()
{
    return mass; 
}

/** Setter for {@link CollisionPdu#location}*/
public CollisionPdu setLocation(Vector3Float pLocation)
{
    location = pLocation;
    return this;
}

/** Getter for {@link CollisionPdu#location}*/
public Vector3Float getLocation()
{
    return location; 
}

/**
 * Serializes an object to a DataOutputStream.
 * @throws java.lang.Exception if something goes wrong
 * @see java.io.DataOutputStream
 * @param dos the OutputStream
 */
public void marshal(DataOutputStream dos) throws Exception
{
    super.marshal(dos);
    try 
    {
       issuingEntityID.marshal(dos);
       collidingEntityID.marshal(dos);
       eventID.marshal(dos);
       collisionType.marshal(dos);
       dos.writeByte(pad);
       velocity.marshal(dos);
       dos.writeFloat(mass);
       location.marshal(dos);
    }
    catch(Exception e)
    {
      System.err.println(e);
    }
}

/**
 * Deserializes an object from a DataInputStream.
 * @throws java.lang.Exception if something goes wrong
 * @see java.io.DataInputStream
 * @param dis the InputStream
 * @return unmarshalled size
 */
public int unmarshal(DataInputStream dis) throws Exception
{
    int uPosition = 0;
    uPosition += super.unmarshal(dis);

    try 
    {
        uPosition += issuingEntityID.unmarshal(dis);
        uPosition += collidingEntityID.unmarshal(dis);
        uPosition += eventID.unmarshal(dis);
        collisionType = CollisionType.unmarshalEnum(dis);
        uPosition += collisionType.getMarshalledSize();
        pad = (byte)dis.readUnsignedByte();
        uPosition += 1;
        uPosition += velocity.unmarshal(dis);
        mass = dis.readFloat();
        uPosition += 4;
        uPosition += location.unmarshal(dis);
    }
    catch(Exception e)
    { 
      System.err.println(e); 
    }
    return getMarshalledSize();
}

/**
 * Packs an object into the ByteBuffer.
 * @throws java.nio.BufferOverflowException if buff is too small
 * @throws java.nio.ReadOnlyBufferException if buff is read only
 * @see java.nio.ByteBuffer
 * @param buff The ByteBuffer at the position to begin writing
 * @throws Exception ByteBuffer-generated exception
 */
public void marshal(java.nio.ByteBuffer buff) throws Exception
{
   super.marshal(buff);
   issuingEntityID.marshal(buff);
   collidingEntityID.marshal(buff);
   eventID.marshal(buff);
   collisionType.marshal(buff);
   buff.put( (byte)pad);
   velocity.marshal(buff);
   buff.putFloat( (float)mass);
   location.marshal(buff);
}

/**
 * Unpacks a Pdu from the underlying data.
 * @throws java.nio.BufferUnderflowException if buff is too small
 * @see java.nio.ByteBuffer
 * @param buff The ByteBuffer at the position to begin reading
 * @return marshalled size
 * @throws Exception ByteBuffer-generated exception
 */
public int unmarshal(java.nio.ByteBuffer buff) throws Exception
{
    super.unmarshal(buff);

    issuingEntityID.unmarshal(buff);
    collidingEntityID.unmarshal(buff);
    eventID.unmarshal(buff);
    collisionType = CollisionType.unmarshalEnum(buff);
    pad = (byte)(buff.get() & 0xFF);
    velocity.unmarshal(buff);
    mass = buff.getFloat();
    location.unmarshal(buff);
    return getMarshalledSize();
}

 /*
  * Override of default equals method.  Calls equalsImpl() for content comparison.
  */
@Override
 public boolean equals(Object obj)
 {
    if(this == obj)
      return true;

    if(obj == null)
       return false;

    if(!getClass().isAssignableFrom(obj.getClass())) //if(getClass() != obj.getClass())
        return false;

    return equalsImpl(obj);
 }

@Override
 public boolean equalsImpl(Object obj)
 {
     boolean ivarsEqual = true;

     final CollisionPdu rhs = (CollisionPdu)obj;

     if( ! (issuingEntityID.equals( rhs.issuingEntityID) )) ivarsEqual = false;
     if( ! (collidingEntityID.equals( rhs.collidingEntityID) )) ivarsEqual = false;
     if( ! (eventID.equals( rhs.eventID) )) ivarsEqual = false;
     if( ! (collisionType == rhs.collisionType)) ivarsEqual = false;
     if( ! (pad == rhs.pad)) ivarsEqual = false;
     if( ! (velocity.equals( rhs.velocity) )) ivarsEqual = false;
     if( ! (mass == rhs.mass)) ivarsEqual = false;
     if( ! (location.equals( rhs.location) )) ivarsEqual = false;
    return ivarsEqual && super.equalsImpl(rhs);
 }

 @Override
 public String toString()
 {
    StringBuilder sb = new StringBuilder();
    sb.append(getClass().getSimpleName()).append(":\n");

    sb.append(" issuingEntityID: ").append(issuingEntityID).append("\n");
    sb.append(" collidingEntityID: ").append(collidingEntityID).append("\n");
    sb.append(" eventID: ").append(eventID).append("\n");
    sb.append(" collisionType: ").append(collisionType).append("\n");
    sb.append(" pad: ").append(pad).append("\n");
    sb.append(" velocity: ").append(velocity).append("\n");
    sb.append(" mass: ").append(mass).append("\n");
    sb.append(" location: ").append(location).append("\n");

   return sb.toString();
 }
} // end of class
